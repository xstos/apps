<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebGL2 Editable Text Editor</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background: #1e1e1e;
            font-family: monospace;
        }
        canvas {
            display: block;
            width: 100%;
            height: 100vh;
            cursor: text;
        }
        #stats {
            position: absolute;
            top: 10px;
            left: 10px;
            color: #fff;
            background: rgba(0,0,0,0.7);
            padding: 10px;
            font-size: 12px;
            pointer-events: none;
        }
        #info {
            position: absolute;
            top: 10px;
            right: 10px;
            color: #fff;
            background: rgba(0,0,0,0.7);
            padding: 10px;
            font-size: 12px;
            max-width: 300px;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <div id="stats">
        FPS: <span id="fps">0</span><br>
        Glyphs: <span id="glyphs">0</span><br>
        Nodes: <span id="nodes">0</span><br>
        Cursor: <span id="cursor">-</span><br>
        Layout: <span id="layout">0</span>ms<br>
        Render: <span id="render">0</span>ms
    </div>
    <div id="info">
        <strong>Controls:</strong><br>
        Click: Position cursor<br>
        Type: Insert text<br>
        Backspace/Delete: Remove text<br>
        Arrow Keys: Move cursor<br>
        Mouse Wheel: Scroll<br>
        +/-: Zoom<br>
        <br>
        Click on any text to start editing!
    </div>

    <script id="vertex-shader" type="x-shader/x-vertex">#version 300 es
        precision highp float;
        
        in vec2 a_position;
        in vec4 a_rect;
        in vec4 a_uv;
        in vec4 a_color;
        
        uniform vec2 u_resolution;
        uniform vec2 u_scroll;
        uniform float u_zoom;
        
        out vec2 v_texCoord;
        out vec4 v_color;
        
        void main() {
            vec2 worldPos = a_rect.xy + a_position * a_rect.zw;
            worldPos = (worldPos - u_scroll) * u_zoom;
            
            vec2 clipSpace = (worldPos / u_resolution) * 2.0 - 1.0;
            clipSpace.y = -clipSpace.y;
            
            gl_Position = vec4(clipSpace, 0.0, 1.0);
            
            v_texCoord = mix(a_uv.xy, a_uv.zw, a_position);
            v_color = a_color;
        }
    </script>

    <script id="fragment-shader" type="x-shader/x-fragment">#version 300 es
        precision highp float;
        
        in vec2 v_texCoord;
        in vec4 v_color;
        
        uniform sampler2D u_fontAtlas;
        
        out vec4 fragColor;
        
        void main() {
            float alpha = texture(u_fontAtlas, v_texCoord).r;
            fragColor = vec4(v_color.rgb, v_color.a * alpha);
        }
    </script>

    <script>
        // ============================================
        // Font Atlas Generator
        // ============================================
        class FontAtlas {
            constructor(fontSize = 16, chars = null) {
                this.fontSize = fontSize;
                this.chars = chars || this.getDefaultChars();
                this.glyphMap = new Map();
                this.canvas = document.createElement('canvas');
                this.ctx = this.canvas.getContext('2d');
                this.generate();
            }
            
            getDefaultChars() {
                let chars = '';
                for (let i = 32; i < 127; i++) {
                    chars += String.fromCharCode(i);
                }
                return chars;
            }
            
            generate() {
                const ctx = this.ctx;
                const fontSize = this.fontSize;
                ctx.font = `${fontSize}px monospace`;
                
                const glyphs = [];
                let maxWidth = 0;
                let maxHeight = fontSize * 1.5;
                
                for (let char of this.chars) {
                    const metrics = ctx.measureText(char);
                    const width = Math.ceil(metrics.width) + 4;
                    maxWidth = Math.max(maxWidth, width);
                    glyphs.push({ char, width, height: maxHeight });
                }
                
                const cols = Math.ceil(Math.sqrt(glyphs.length));
                const rows = Math.ceil(glyphs.length / cols);
                const cellWidth = maxWidth;
                const cellHeight = maxHeight;
                
                this.canvas.width = cols * cellWidth;
                this.canvas.height = rows * cellHeight;
                
                ctx.font = `${fontSize}px monospace`;
                ctx.textBaseline = 'top';
                ctx.fillStyle = 'white';
                
                let index = 0;
                for (let glyph of glyphs) {
                    const col = index % cols;
                    const row = Math.floor(index / cols);
                    const x = col * cellWidth + 2;
                    const y = row * cellHeight + 2;
                    
                    ctx.fillText(glyph.char, x, y);
                    
                    this.glyphMap.set(glyph.char, {
                        u0: (col * cellWidth) / this.canvas.width,
                        v0: (row * cellHeight) / this.canvas.height,
                        u1: ((col + 1) * cellWidth) / this.canvas.width,
                        v1: ((row + 1) * cellHeight) / this.canvas.height,
                        width: glyph.width - 4,
                        height: glyph.height - 4,
                        advanceX: glyph.width - 2
                    });
                    
                    index++;
                }
            }
            
            getGlyph(char) {
                return this.glyphMap.get(char) || this.glyphMap.get('?');
            }
        }
        
        // ============================================
        // Cursor
        // ============================================
        class Cursor {
            constructor() {
                this.node = null;      // Current TextNode
                this.index = 0;        // Character index in node.text
                this.blinkState = true;
                this.lastBlink = Date.now();
            }
            
            setPosition(node, index) {
                this.node = node;
                this.index = Math.max(0, Math.min(index, node.text.length));
                this.resetBlink();
            }
            
            resetBlink() {
                this.blinkState = true;
                this.lastBlink = Date.now();
            }
            
            update() {
                if (Date.now() - this.lastBlink > 500) {
                    this.blinkState = !this.blinkState;
                    this.lastBlink = Date.now();
                }
            }
            
            moveLeft() {
                if (this.index > 0) {
                    this.index--;
                    this.resetBlink();
                }
            }
            
            moveRight() {
                if (this.node && this.index < this.node.text.length) {
                    this.index++;
                    this.resetBlink();
                }
            }
            
            insertText(text) {
                if (this.node) {
                    this.node.insertTextAt(this.index, text);
                    this.index += text.length;
                    this.resetBlink();
                }
            }
            
            deleteBackward() {
                if (this.node && this.index > 0) {
                    this.node.deleteTextAt(this.index - 1, 1);
                    this.index--;
                    this.resetBlink();
                }
            }
            
            deleteForward() {
                if (this.node && this.index < this.node.text.length) {
                    this.node.deleteTextAt(this.index, 1);
                    this.resetBlink();
                }
            }
        }
        
        // ============================================
        // Document Structure
        // ============================================
        class TextNode {
            constructor(text = '', style = {}) {
                this.text = text;
                this.children = [];
                this.parent = null;
                this.style = {
                    color: style.color || [1, 1, 1, 1],
                    padding: style.padding || 5,
                    margin: style.margin || 0,
                    backgroundColor: style.backgroundColor || null,
                    width: style.width || null,
                    minWidth: style.minWidth || 0,
                    display: style.display || 'inline',
                    editable: style.editable !== false // Editable by default
                };
                
                this.bounds = { x: 0, y: 0, width: 0, height: 0 };
                this.layoutDirty = true;
                this.glyphPositions = []; // For hit testing
            }
            
            addChild(node) {
                node.parent = this;
                this.children.push(node);
                this.invalidate();
                return node;
            }
            
            invalidate() {
                this.layoutDirty = true;
                if (this.parent) {
                    this.parent.invalidate();
                }
            }
            
            insertTextAt(index, text) {
                this.text = this.text.slice(0, index) + text + this.text.slice(index);
                this.invalidate();
            }
            
            deleteTextAt(index, length = 1) {
                this.text = this.text.slice(0, index) + this.text.slice(index + length);
                this.invalidate();
            }
        }
        
        // ============================================
        // Flow Layout Engine
        // ============================================
        class FlowLayout {
            constructor(fontAtlas) {
                this.fontAtlas = fontAtlas;
            }
            
            layout(node, containerWidth, x = 0, y = 0) {
                const startTime = performance.now();
                this.layoutNode(node, containerWidth, x, y);
                return performance.now() - startTime;
            }
            
            layoutNode(node, containerWidth, x, y) {
                const style = node.style;
                const padding = style.padding;
                
                let cursorX = x + padding;
                let cursorY = y + padding;
                let lineHeight = this.fontAtlas.fontSize;
                let maxLineWidth = 0;
                let contentHeight = 0;
                
                const effectiveWidth = style.width || containerWidth;
                const innerWidth = effectiveWidth - padding * 2;
                
                // Clear glyph positions
                node.glyphPositions = [];
                
                // Layout text content
                if (node.text) {
                    for (let i = 0; i < node.text.length; i++) {
                        const char = node.text[i];
                        const glyph = this.fontAtlas.getGlyph(char);
                        
                        // Handle newlines
                        if (char === '\n') {
                            cursorX = x + padding;
                            cursorY += lineHeight;
                            continue;
                        }
                        
                        // Line wrap
                        if (cursorX + glyph.advanceX > x + innerWidth + padding) {
                            cursorX = x + padding;
                            cursorY += lineHeight;
                        }
                        
                        // Store glyph position for hit testing
                        node.glyphPositions.push({
                            x: cursorX,
                            y: cursorY,
                            width: glyph.width,
                            height: glyph.height,
                            index: i
                        });
                        
                        cursorX += glyph.advanceX;
                        maxLineWidth = Math.max(maxLineWidth, cursorX - x - padding);
                    }
                    
                    contentHeight = cursorY - y + lineHeight;
                }
                
                // Layout children
                for (let child of node.children) {
                    if (child.style.display === 'block') {
                        cursorX = x + padding;
                        cursorY = contentHeight > 0 ? y + contentHeight + padding : cursorY;
                        
                        this.layoutNode(child, innerWidth, cursorX, cursorY);
                        
                        maxLineWidth = Math.max(maxLineWidth, child.bounds.width);
                        contentHeight = child.bounds.y + child.bounds.height - y;
                        cursorY = y + contentHeight;
                    } else {
                        const childWidth = child.style.width || 100;
                        
                        if (cursorX + childWidth > x + innerWidth + padding) {
                            cursorX = x + padding;
                            cursorY += lineHeight;
                        }
                        
                        this.layoutNode(child, childWidth, cursorX, cursorY);
                        
                        cursorX += child.bounds.width + style.margin;
                        maxLineWidth = Math.max(maxLineWidth, cursorX - x - padding);
                        contentHeight = Math.max(contentHeight, child.bounds.y + child.bounds.height - y);
                    }
                }
                
                node.bounds.x = x;
                node.bounds.y = y;
                node.bounds.width = Math.max(maxLineWidth + padding * 2, style.minWidth);
                node.bounds.height = contentHeight + padding * 2;
                node.layoutDirty = false;
            }
        }
        
        // ============================================
        // Hit Testing
        // ============================================
        class HitTester {
            constructor() {}
            
            // Find node and character index at screen position
            hitTest(rootNode, worldX, worldY) {
                let bestNode = null;
                let bestIndex = 0;
                let bestDistance = Infinity;
                
                const traverse = (node) => {
                    // Check if point is in node bounds
                    const bounds = node.bounds;
                    if (worldX < bounds.x || worldX > bounds.x + bounds.width ||
                        worldY < bounds.y || worldY > bounds.y + bounds.height) {
                        return;
                    }
                    
                    // Check glyphs in this node
                    if (node.text && node.style.editable) {
                        for (let gp of node.glyphPositions) {
                            const centerX = gp.x + gp.width / 2;
                            const centerY = gp.y + gp.height / 2;
                            const dist = Math.abs(worldX - centerX) + Math.abs(worldY - centerY);
                            
                            if (dist < bestDistance) {
                                bestDistance = dist;
                                bestNode = node;
                                // Click on left half = before char, right half = after char
                                bestIndex = worldX < centerX ? gp.index : gp.index + 1;
                            }
                        }
                        
                        // If node has text but no glyphs hit, place cursor at end
                        if (!bestNode && node.text.length === 0) {
                            bestNode = node;
                            bestIndex = 0;
                            bestDistance = 0;
                        }
                    }
                    
                    // Traverse children
                    for (let child of node.children) {
                        traverse(child);
                    }
                };
                
                traverse(rootNode);
                
                return bestNode ? { node: bestNode, index: bestIndex } : null;
            }
        }
        
        // ============================================
        // WebGL2 Renderer
        // ============================================
        class WebGLRenderer {
            constructor(canvas, fontAtlas) {
                this.canvas = canvas;
                this.fontAtlas = fontAtlas;
                
                const gl = canvas.getContext('webgl2', {
                    alpha: false,
                    antialias: false
                });
                
                if (!gl) {
                    throw new Error('WebGL2 not supported');
                }
                
                this.gl = gl;
                this.maxGlyphs = 100000;
                this.instanceData = new Float32Array(this.maxGlyphs * 12);
                
                this.setupShaders();
                this.setupBuffers();
                this.setupTexture();
                
                this.scroll = { x: 0, y: 0 };
                this.zoom = 1.0;
            }
            
            setupShaders() {
                const gl = this.gl;
                
                const vertexShader = this.compileShader(
                    document.getElementById('vertex-shader').textContent,
                    gl.VERTEX_SHADER
                );
                const fragmentShader = this.compileShader(
                    document.getElementById('fragment-shader').textContent,
                    gl.FRAGMENT_SHADER
                );
                
                const program = gl.createProgram();
                gl.attachShader(program, vertexShader);
                gl.attachShader(program, fragmentShader);
                gl.linkProgram(program);
                
                if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                    throw new Error('Program link failed: ' + gl.getProgramInfoLog(program));
                }
                
                this.program = program;
                
                this.attribLocations = {
                    position: gl.getAttribLocation(program, 'a_position'),
                    rect: gl.getAttribLocation(program, 'a_rect'),
                    uv: gl.getAttribLocation(program, 'a_uv'),
                    color: gl.getAttribLocation(program, 'a_color')
                };
                
                this.uniformLocations = {
                    resolution: gl.getUniformLocation(program, 'u_resolution'),
                    scroll: gl.getUniformLocation(program, 'u_scroll'),
                    zoom: gl.getUniformLocation(program, 'u_zoom'),
                    fontAtlas: gl.getUniformLocation(program, 'u_fontAtlas')
                };
            }
            
            compileShader(source, type) {
                const gl = this.gl;
                const shader = gl.createShader(type);
                gl.shaderSource(shader, source);
                gl.compileShader(shader);
                
                if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                    const log = gl.getShaderInfoLog(shader);
                    gl.deleteShader(shader);
                    throw new Error('Shader compile failed: ' + log);
                }
                
                return shader;
            }
            
            setupBuffers() {
                const gl = this.gl;
                
                const quadVertices = new Float32Array([
                    0, 0,
                    1, 0,
                    0, 1,
                    1, 1
                ]);
                
                this.vao = gl.createVertexArray();
                gl.bindVertexArray(this.vao);
                
                const quadBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, quadBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, quadVertices, gl.STATIC_DRAW);
                gl.enableVertexAttribArray(this.attribLocations.position);
                gl.vertexAttribPointer(this.attribLocations.position, 2, gl.FLOAT, false, 0, 0);
                
                this.instanceBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, this.instanceBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, this.instanceData.byteLength, gl.DYNAMIC_DRAW);
                
                const stride = 12 * 4;
                
                gl.enableVertexAttribArray(this.attribLocations.rect);
                gl.vertexAttribPointer(this.attribLocations.rect, 4, gl.FLOAT, false, stride, 0);
                gl.vertexAttribDivisor(this.attribLocations.rect, 1);
                
                gl.enableVertexAttribArray(this.attribLocations.uv);
                gl.vertexAttribPointer(this.attribLocations.uv, 4, gl.FLOAT, false, stride, 16);
                gl.vertexAttribDivisor(this.attribLocations.uv, 1);
                
                gl.enableVertexAttribArray(this.attribLocations.color);
                gl.vertexAttribPointer(this.attribLocations.color, 4, gl.FLOAT, false, stride, 32);
                gl.vertexAttribDivisor(this.attribLocations.color, 1);
                
                gl.bindVertexArray(null);
            }
            
            setupTexture() {
                const gl = this.gl;
                
                this.texture = gl.createTexture();
                gl.bindTexture(gl.TEXTURE_2D, this.texture);
                
                gl.texImage2D(
                    gl.TEXTURE_2D,
                    0,
                    gl.R8,
                    gl.RED,
                    gl.UNSIGNED_BYTE,
                    this.fontAtlas.canvas
                );
                
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
            }
            
            resize() {
                const displayWidth = this.canvas.clientWidth;
                const displayHeight = this.canvas.clientHeight;
                
                if (this.canvas.width !== displayWidth || this.canvas.height !== displayHeight) {
                    this.canvas.width = displayWidth;
                    this.canvas.height = displayHeight;
                    this.gl.viewport(0, 0, displayWidth, displayHeight);
                }
            }
            
            screenToWorld(screenX, screenY) {
                return {
                    x: (screenX / this.zoom) + this.scroll.x,
                    y: (screenY / this.zoom) + this.scroll.y
                };
            }
            
            worldToScreen(worldX, worldY) {
                return {
                    x: (worldX - this.scroll.x) * this.zoom,
                    y: (worldY - this.scroll.y) * this.zoom
                };
            }
            
            render(rootNode, viewport, cursor) {
                const gl = this.gl;
                const startTime = performance.now();
                
                this.resize();
                
                gl.clearColor(0.12, 0.12, 0.12, 1.0);
                gl.clear(gl.COLOR_BUFFER_BIT);
                
                gl.enable(gl.BLEND);
                gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
                
                let instanceCount = 0;
                this.collectGlyphs(rootNode, viewport, cursor, (data, count) => {
                    instanceCount = count;
                });
                
                if (instanceCount === 0) {
                    return { renderTime: performance.now() - startTime, glyphCount: 0 };
                }
                
                gl.bindBuffer(gl.ARRAY_BUFFER, this.instanceBuffer);
                gl.bufferSubData(
                    gl.ARRAY_BUFFER,
                    0,
                    this.instanceData.subarray(0, instanceCount * 12)
                );
                
                gl.useProgram(this.program);
                gl.bindVertexArray(this.vao);
                
                gl.uniform2f(this.uniformLocations.resolution, this.canvas.width, this.canvas.height);
                gl.uniform2f(this.uniformLocations.scroll, this.scroll.x, this.scroll.y);
                gl.uniform1f(this.uniformLocations.zoom, this.zoom);
                gl.uniform1i(this.uniformLocations.fontAtlas, 0);
                
                gl.activeTexture(gl.TEXTURE0);
                gl.bindTexture(gl.TEXTURE_2D, this.texture);
                
                gl.drawArraysInstanced(gl.TRIANGLE_STRIP, 0, 4, instanceCount);
                
                return {
                    renderTime: performance.now() - startTime,
                    glyphCount: instanceCount
                };
            }
            
            collectGlyphs(node, viewport, cursor, callback) {
                const instances = this.instanceData;
                let offset = 0;
                
                const traverse = (node) => {
                    const bounds = node.bounds;
                    if (bounds.x + bounds.width < viewport.x ||
                        bounds.x > viewport.x + viewport.width ||
                        bounds.y + bounds.height < viewport.y ||
                        bounds.y > viewport.y + viewport.height) {
                        return;
                    }
                    
                    // Render text
                    if (node.text) {
                        let x = bounds.x + node.style.padding;
                        let y = bounds.y + node.style.padding;
                        const lineHeight = this.fontAtlas.fontSize;
                        const innerWidth = bounds.width - node.style.padding * 2;
                        
                        for (let i = 0; i < node.text.length; i++) {
                            if (offset >= this.maxGlyphs) break;
                            
                            const char = node.text[i];
                            
                            if (char === '\n') {
                                x = bounds.x + node.style.padding;
                                y += lineHeight;
                                continue;
                            }
                            
                            const glyph = this.fontAtlas.getGlyph(char);
                            
                            if (x + glyph.advanceX > bounds.x + innerWidth + node.style.padding) {
                                x = bounds.x + node.style.padding;
                                y += lineHeight;
                            }
                            
                            const idx = offset * 12;
                            instances[idx + 0] = x;
                            instances[idx + 1] = y;
                            instances[idx + 2] = glyph.width;
                            instances[idx + 3] = glyph.height;
                            instances[idx + 4] = glyph.u0;
                            instances[idx + 5] = glyph.v0;
                            instances[idx + 6] = glyph.u1;
                            instances[idx + 7] = glyph.v1;
                            instances[idx + 8] = node.style.color[0];
                            instances[idx + 9] = node.style.color[1];
                            instances[idx + 10] = node.style.color[2];
                            instances[idx + 11] = node.style.color[3];
                            
                            x += glyph.advanceX;
                            offset++;
                        }
                        
                        // Draw cursor if this is the active node
                        if (cursor.node === node && cursor.blinkState) {
                            if (offset < this.maxGlyphs) {
                                let cursorX, cursorY;
                                
                                if (cursor.index < node.glyphPositions.length) {
                                    const gp = node.glyphPositions[cursor.index];
                                    cursorX = gp.x;
                                    cursorY = gp.y;
                                } else if (node.glyphPositions.length > 0) {
                                    const lastGp = node.glyphPositions[node.glyphPositions.length - 1];
                                    const lastChar = node.text[node.text.length - 1];
                                    const lastGlyph = this.fontAtlas.getGlyph(lastChar);
                                    cursorX = lastGp.x + lastGlyph.advanceX;
                                    cursorY = lastGp.y;
                                } else {
                                    cursorX = bounds.x + node.style.padding;
                                    cursorY = bounds.y + node.style.padding;
                                }
                                
                                // Render cursor as a thin rectangle
                                const idx = offset * 12;
                                instances[idx + 0] = cursorX;
                                instances[idx + 1] = cursorY;
                                instances[idx + 2] = 2; // width
                                instances[idx + 3] = lineHeight;
                                instances[idx + 4] = 0;
                                instances[idx + 5] = 0;
                                instances[idx + 6] = 0;
                                instances[idx + 7] = 0;
                                instances[idx + 8] = 1.0;
                                instances[idx + 9] = 1.0;
                                instances[idx + 10] = 1.0;
                                instances[idx + 11] = 1.0;
                                
                                offset++;
                            }
                        }
                    }
                    
                    for (let child of node.children) {
                        traverse(child);
                    }
                };
                
                traverse(node);
                callback(instances, offset);
            }
        }
        
        // ============================================
        // Application
        // ============================================
        class TextEditor {
            constructor(canvas) {
                this.canvas = canvas;
                this.fontAtlas = new FontAtlas(14);
                this.renderer = new WebGLRenderer(canvas, this.fontAtlas);
                this.layout = new FlowLayout(this.fontAtlas);
                this.hitTester = new HitTester();
                this.cursor = new Cursor();
                
                this.root = this.createDemoDocument();
                
                // Set initial cursor position
                const firstEditableNode = this.findFirstEditableNode(this.root);
                if (firstEditableNode) {
                    this.cursor.setPosition(firstEditableNode, 0);
                }
                
                this.frameCount = 0;
                this.lastFpsUpdate = performance.now();
                this.fps = 0;
                
                this.setupInput();
                this.render();
            }
            
            findFirstEditableNode(node) {
                if (node.text && node.style.editable) {
                    return node;
                }
                for (let child of node.children) {
                    const found = this.findFirstEditableNode(child);
                    if (found) return found;
                }
                return null;
            }
            
            createDemoDocument() {
                const root = new TextNode('', {
                    display: 'block',
                    padding: 20,
                    width: 1200
                });
                
                const title = new TextNode('WebGL2 Editable Text Editor', {
                    color: [0.3, 0.7, 1.0, 1.0],
                    display: 'block',
                    padding: 10,
                    margin: 10
                });
                root.addChild(title);
                
                const p1 = new TextNode(
                    'Click anywhere in this text to start editing. You can type, delete, and move the cursor with arrow keys.',
                    {
                        display: 'block',
                        padding: 10,
                        margin: 10
                    }
                );
                root.addChild(p1);
                
                const p2 = new TextNode(
                    'Try editing this paragraph! Add new text, delete characters, or move the cursor around.',
                    {
                        display: 'block',
                        padding: 10,
                        margin: 10
                    }
                );
                root.addChild(p2);
                
                // Code block
                const code = new TextNode(
                    'function example() {\n    // Edit me!\n    console.log("Hello");\n}',
                    {
                        color: [0.5, 1.0, 0.5, 1.0],
                        display: 'block',
                        padding: 15,
                        margin: 10
                    }
                );
                root.addChild(code);
                
                // More editable paragraphs
                for (let i = 0; i < 10; i++) {
                    const p = new TextNode(
                        `Paragraph ${i + 1}: This is editable text. Click and type to modify it.`,
                        {
                            display: 'block',
                            padding: 10,
                            margin: 5
                        }
                    );
                    root.addChild(p);
                }
                
                return root;
            }
            
            setupInput() {
                // Mouse click for cursor positioning
                this.canvas.addEventListener('mousedown', (e) => {
                    const rect = this.canvas.getBoundingClientRect();
                    const screenX = e.clientX - rect.left;
                    const screenY = e.clientY - rect.top;
                    
                    const world = this.renderer.screenToWorld(screenX, screenY);
                    const hit = this.hitTester.hitTest(this.root, world.x, world.y);
                    
                    if (hit) {
                        this.cursor.setPosition(hit.node, hit.index);
                    }
                });
                
                // Keyboard input
                window.addEventListener('keydown', (e) => {
                    // Cursor movement
                    if (e.key === 'ArrowLeft') {
                        this.cursor.moveLeft();
                        e.preventDefault();
                        return;
                    }
                    if (e.key === 'ArrowRight') {
                        this.cursor.moveRight();
                        e.preventDefault();
                        return;
                    }
                    
                    // Scrolling
                    const scrollSpeed = 20;
                    if (e.key === 'ArrowUp' && !e.shiftKey) {
                        this.renderer.scroll.y -= scrollSpeed;
                        e.preventDefault();
                        return;
                    }
                    if (e.key === 'ArrowDown' && !e.shiftKey) {
                        this.renderer.scroll.y += scrollSpeed;
                        e.preventDefault();
                        return;
                    }
                    
                    // Zoom
                    if (e.key === '+' || e.key === '=') {
                        this.renderer.zoom = Math.min(3.0, this.renderer.zoom * 1.1);
                        e.preventDefault();
                        return;
                    }
                    if (e.key === '-') {
                        this.renderer.zoom = Math.max(0.3, this.renderer.zoom / 1.1);
                        e.preventDefault();
                        return;
                    }
                    
                    // Text editing
                    if (e.key === 'Backspace') {
                        this.cursor.deleteBackward();
                        e.preventDefault();
                        return;
                    }
                    if (e.key === 'Delete') {
                        this.cursor.deleteForward();
                        e.preventDefault();
                        return;
                    }
                    if (e.key === 'Enter') {
                        this.cursor.insertText('\n');
                        e.preventDefault();
                        return;
                    }
                    
                    // Regular text input
                    if (e.key.length === 1 && !e.ctrlKey && !e.metaKey) {
                        this.cursor.insertText(e.key);
                        e.preventDefault();
                    }
                });
                
                // Mouse wheel scroll
                this.canvas.addEventListener('wheel', (e) => {
                    e.preventDefault();
                    this.renderer.scroll.y += e.deltaY * 0.5;
                    this.renderer.scroll.x += e.deltaX * 0.5;
                });
            }
            
            countNodes(node) {
                let count = 1;
                for (let child of node.children) {
                    count += this.countNodes(child);
                }
                return count;
            }
            
            render() {
                requestAnimationFrame(() => this.render());
                
                this.cursor.update();
                
                const layoutStart = performance.now();
                const viewport = {
                    x: this.renderer.scroll.x,
                    y: this.renderer.scroll.y,
                    width: this.canvas.width,
                    height: this.canvas.height
                };
                
                if (this.root.layoutDirty) {
                    this.layout.layout(this.root, this.canvas.width);
                }
                const layoutTime = performance.now() - layoutStart;
                
                const result = this.renderer.render(this.root, viewport, this.cursor);
                
                this.frameCount++;
                const now = performance.now();
                if (now - this.lastFpsUpdate > 500) {
                    this.fps = Math.round(this.frameCount / (now - this.lastFpsUpdate) * 1000);
                    this.frameCount = 0;
                    this.lastFpsUpdate = now;
                    
                    document.getElementById('fps').textContent = this.fps;
                    document.getElementById('glyphs').textContent = result.glyphCount;
                    document.getElementById('nodes').textContent = this.countNodes(this.root);
                    
                    if (this.cursor.node) {
                        document.getElementById('cursor').textContent = 
                            `Node text length: ${this.cursor.node.text.length}, Index: ${this.cursor.index}`;
                    }
                    
                    document.getElementById('layout').textContent = layoutTime.toFixed(2);
                    document.getElementById('render').textContent = result.renderTime.toFixed(2);
                }
            }
        }
        
        // ============================================
        // Initialize
        // ============================================
        window.addEventListener('load', () => {
            const canvas = document.getElementById('canvas');
            const editor = new TextEditor(canvas);
            window.editor = editor;
            console.log('Editable text editor initialized');
        });
    </script>
</body>
</html>
